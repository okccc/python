- [参考文档](https://www.jianshu.com/p/acc8b158daef) 

## over()
- 窗口/分析函数经常和over()结合使用,over指定条件  
<font color=red>function(arg1,....argn) over([partition by(分组依据)] [order by(排序依据)] [window_clause(窗口条件)])</font>  
缺少window_clause时默认：range between unbounded preceding and current row  
缺少order_by和window_clause时默认：row between unbounded preceding and unbounded following
- 聚合函数返回一个值,分析函数返回一个数据集,分析数据集可以解决很多问题  
- 分区排序
- 动态group by
- 求 Top n
- 累计计算
- 层次查询

## window
function|explain
:---:|:---:
first_value|取分组排序后截止到当前行的第一个值
last_value|取分组排序后截止到当前行的最后一个值
lag(col,n,default)|统计窗口内往上第n行的col值,null就取default
lead(col,n,default)|统计窗口内往下第n行的col值,null就取default
- window_clause
```sql
select month,  
       sum(amount) pay_amount,  
       -- 所有月份累计和
       sum(sum(amount)) over(order by month) s1,
       -- 前3个月累计和
       sum(sum(amount)) over(order by month rows between 3 preceding and current row) s2,
       -- 前一月后一月和本月累计和
       sum(sum(amount)) over(order by month rows between 1 preceding and 1 following) s3,   
       -- 前一月后一月本月平均值
       avg(sum(amount)) over(order by month rows between 1 preceding and 1 following) a1
from data_pay_info        
group by month;    
```    
## analysis  
function|explain
:---:|:---:
row_number()|给分组记录添加排名 12345
rank()|同上 12335
dense_rank()|同上 12334
cume_dist()|低于当前值的行数/分组内总行数,比如低于当前薪水的人数占比
percent_rank()|分组内当前行的rank值-1/分组内总行数-1
ntile(n)|将分组数据切片,可用于取百分比
- ntile
```sql
select name,cost, 
       -- 全局数据,切成3分 
       ntile(3) over() as n1,
       -- 按name分组,数据切成3份        
       ntile(3) over(partition by name) as n2, 
       -- 按cost排序,数据切成3份 
       ntile(3) over(order by cost) as n3,  
       -- 按name分组并按cost升序,数据切成3份     
       ntile(3) over(partition by name order by cost) as n4   
-- 求sale前10%的用户id
select uid 
from 
(select uid,ntile(10) over(order by sale desc) as nt from orders) a 
where nt=1;
``` 
- row_number | rank | dense_rank  
```sql
select cookieid,pv,  
       rank() over(partition by cookieid order by pv desc) as rn1,  
       dense_rank() over(partition by cookieid order by pv desc) as rn2,  
       row_number() over(partition by cookieid order by pv desc) as rn3   
```
- 用户留存问题  
```sql
select s.day,  
       count(distinct s.imei) as "当日活跃人数",   
       count(distinct case when datediff(t.day, s.day) = 1 then s.imei end) as "次日留存人数",      
       count(distinct case when datediff(t.day, s.day) = 7 then s.imei end) as "第七日留存人数"  
from  
(  
     select imei,day  
     from dm_imei_user_daily  
     where day between "2017-11-01" and "2017-12-31"  
) s  
left join  
(  
     select imei,day  
     from dm_imei_user_daily  
     where day between "2017-11-01" and "2018-01-07"  
) t on s.imei = t.imei  
group by s.day;
```