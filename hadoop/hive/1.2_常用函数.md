## string
```sql
-- 长度
hive> select length('abcedfg');
-- 反转
hive> select reverse('abcedfg');  
-- 拼接
hive> select concat('abc','def','gh');  
-- 使用分隔符拼接
hive> select concat_ws(',','abc','def','gh'); 
-- split：将字符串切割成数组
hive> select split('abtcdtef','t');  
-- collect_list/set：行转列,去重/不去重
hive> select concat_ws(',',collect_list(column));  

-- sort_array：对数组元素排序
hive> select concat_ws(',',sort_array(collect_list(column)));  
-- explode：列转行,将array元素切分成多行,通常结合lateral view使用
hive> select explode(split(concat_ws(',',collect_set(column)),','));  
-- 去空格
hive> select trim(' abc ');  
-- 截取
hive> select substring('facebook',3);  
hive> select substring('facebook',-3);  
hive> select substring('facebook',3,2);  
hive> select substring('facebook',-3,2);  
-- 将字符串切割成键值对
hive> select str_to_map('aaa:11&bbb:22', '&', ':');  
hive> select str_to_map('aaa:11&bbb:22', '&', ':')['aaa'];  
-- 空值处理
hive> select nvl(field,'-');  
-- 索引
hive> select instr('abcde','c');
-- 替换
hive> select regexp_replace('2019-01-01','-','');
-- 抽取
hive> select regexp_extract('foothebar', 'foo(.*?)(bar)', 1);  
hive> select regexp_extract('foothebar', 'foo(.*?)(bar)', 2);  
hive> select regexp_extract('foothebar', 'foo(.*?)(bar)', 0);  
-- 解析url
hive> select parse_url('http://facebook.com/path/p1.php?query=1', 'PROTOCOL');           -- http  
hive> select parse_url('http://facebook.com/path/p1.php?query=1', 'HOST');		         -- facebook.com​  
hive> select parse_url('http://facebook.com/path/p1.php?query=1', 'PATH');		         -- /path/p1.php​  
hive> select parse_url('http://facebook.com/path/p1.php?query=1', 'QUERY');		         -- query=1  
hive> select parse_url('http://facebook.com/path/p1.php?query=1', 'QUERY','query');	     --  1  
hive> ​select parse_url('http://facebook.com/path/p1.php?query=1', 'FILE');			     -- /path/p1.php?query=1​  
-- 解析json字符串
hive> select nvl(get_json_object(t.json,'$.timestamp'),'-');  
-- 使用java类中的方法
hive> select reflect('java.net.urldecoder','decode','...');      -- 中文解码  
hive> select reflect("java.lang.string", "valueof", 1)         	 -- 1  
hive> select reflect("java.lang.string", "isempty")              -- true  
hive> select reflect("java.lang.math", "max", 2, 3)              -- 3  
hive> select reflect("java.lang.math", "round", 2.5)             -- 3  
hive> select reflect("java.lang.math", "exp", 1.0)            	 -- 2.7182818284590455  
hive> select reflect("java.lang.math", "floor", 1.9)           	 -- 1.0  
-- ascii：返回字符串第一个字符的ascii码  ascii - gbk - unicode - utf8
hive> select ascii('abcde');  
-- repeat,返回重复n次后的str字符串
hive> select repeat('abc',5);  
-- lpad：字符串补位
hive> select lpad('abc',10,'td');  
hive> select rpad('abc',10,'td');  
```

## time
```sql
-- 当前日期
hive> select current_date;
-- 当前时间戳
hive> select current_timestamp;  
-- unix格式时间戳
hive> select unix_timestamp();  
-- 格式转换
hive> select from_unixtime(unix_timestamp(dt, 'yyyymmdd'),'yyyy-mm-dd');  
-- year/month/day/hour/minute/second
hive> select year('2016-10-19 16:23:08');  
-- 截取日期
hive> select to_date('2011-12-08 10:03:01');  
-- 日期增加
hive> select date_add('2016-10-18',10);  
-- 日起减少
hive> select date_sub('2016-10-18',10);   
-- 日期差值
hive> select datediff('2016-10-19','2016-03-15');  
-- 月份增加
hive> select add_months('2009-08-31', 1);    
-- trunc：某年(月)的第一天
hive> select trunc('2018-08-20','YY');  
hive> select trunc('2018-10-24','MM'); 
-- last_day：某月最后一天
hive> select last_day('2018-05-12');  
-- 上个月今天/第一天/最后一天
hive> select add_months(current_date,-1);  
hive> select add_months(trunc(current_date,'MM'),-1);  
hive> select add_months(last_day(current_date),-1);  
-- 上个季度第一天/最后一天
hive> select case when month(current_date) in (1,2,3) then add_months(trunc(current_date,'YY'),-3)
                  when month(current_date) in (4,5,6) then trunc(current_date,'YY')
                  when month(current_date) in (7,8,9) then add_months(trunc(current_date,'YY'),3)
                  when month(current_date) in (10,11,12) then add_months(trunc(current_date,'YY'),6) end;
hive> select case when month(current_date) in (1,2,3) then date_sub(trunc(current_date,'YY'),1)
                  when month(current_date) in (4,5,6) then date_sub(add_months(trunc(current_date,'YY'),3),1)
                  when month(current_date) in (7,8,9) then date_sub(add_months(trunc(current_date,'YY'),6),1)
                  when month(current_date) in (10,11,12) then date_sub(add_months(trunc(current_date,'YY'),9),1) end;
-- 去年今天/第一天/最后一天
hive> select add_months(current_date,-12);
hive> select add_months(trunc(current_date,'YY'),-12);
hive> select date_sub(trunc(current_date,'YY'),1);
-- 一年中的周数
hive> select weekofyear('2016-10-19 12:13:25'); 
-- 计算某个日期是星期几(0~6对应星期日~星期六)
hive> select pmod(datediff(current_date,'2020-04-26'),7);  # 2020-04-26是计算日期前面的任一星期日
-- 上个星期第一天/最后一天(减去pmod()是因为一年中的第一天不一定就是星期一)
hive> select date_add(trunc(current_date,'YY'), (weekofyear(current_date)-2)*7 - pmod(datediff(trunc(current_date,'YY'),'2019-12-15'),7) +1);
hive> select date_add(trunc(current_date,'YY'), (weekofyear(current_date)-1)*7 - pmod(datediff(trunc(current_date,'YY'),'2019-12-15'),7));
```

## math
```sql
-- round
hive> select round(3.5);  
hive> select round(3.1415926,4);  
-- floo
hive> select floor(3.1415926);  
-- ceil
hive> select ceil(3.1415926);  
-- rand
hive> select rand();  
0.5577432776034763  
-- exp：计算自然对数e的a次方
hive> select exp(2);  
-- ln：计算a的自然对数e
hive> select ln(7.38905609893065);  
-- log10：计算以10为底a的对数
hive> select log10(100);  
-- log2：计算以2为底a的对数
hive> select log2(8);  
-- log：计算以a为底b的对数
hive> select log(4, 256);  
-- pmod：计算a除以b的余数
hive> select pmod(9,4);  
-- pow：计算a的p次幂
hive> select pow(2,4);  
-- sqrt：计算a的平方根
hive> select sqrt(16);  
-- bin：计算a的二进制代表示
hive> select bin(7);  
-- hex：计算a的十六进制表示
hive> select hex(17);  
hive> select hex('abc');  
-- unhex；计算该十六进制字符串所代表的字符串
hive> select unhex('616263');  
-- conv：将数字从一个进制转换成另一个进制
hive> select conv(17,10,16);  
hive> select conv(17,10,2);  
-- abs：计算绝对值
hive> select abs(-3.9);  
-- sin：计算a的正弦值
hive> select sin(0.8);  
-- asin：计算a的反正弦值
hive> select asin(0.7173560908995228);  
-- cos：计算a的余弦值
hive> select cos(0.9);  
-- acos：计算a的反余弦值
hive> select acos(0.6216099682706644);
-- positive：返回a本身
hive> select positive(-10);  
-- negative：返回a的相反数
hive> select negative(-5);  
```

## over()

```sql
-- 聚合函数返回一个值,分析函数返回一个数据集,再分析数据集可以解决很多问题
-- 窗口/分析函数经常和over()结合使用,over指定条件
function(arg1,arg2..) over([partition by(分组依据)] [order by(排序依据)] [window_clause(窗口条件)]) 
-- 缺少window_clause时默认：range between unbounded preceding and current row
-- 缺少order_by和window_clause时默认：row between unbounded preceding and unbounded following

-- topK
-- 选出每个学校,每个年级,分数前三的科目
select t.*
from
(
    select school,class,subjects,score,
           row_number() over (partition by school,class,subjects order by score desc) rn
    from scores
) t
where t.rn <= 3;

-- topK%
-- 求sale前10%的业务员和销售额
select t.*
from 
(
    select uid,sale,ntile(10) over(order by sale desc) as n from orders
) t 
where t.n = 1;
-- 在1亿条数据中找出前100万大的 -> 引申含义就是找出前1%大的
-- 1亿条数据分布在集群10个节点上,找出前1万大的 -> 先在每个节点找出前1万大的,这样数据总量减少为10万,然后再找出这10万条数据中排前1万的
select t.*
from 
(
    select num,ntile(100) over(order by num desc) as n from datas
) t
where t.n = 1;

-- 用户留存问题
select s.stat_date,  
       count(distinct s.imei) as "当日活跃人数",
       count(distinct case when datediff(t.stat_date, s.stat_date) = 1 then s.imei end) as "次日留存人数", 
       count(distinct case when datediff(t.stat_date, s.stat_date) = 7 then s.imei end) as "第七日留存人数"
from  
(select imei,stat_date from dm_user_daily where stat_date between "2020-03-01" and "2020-03-31") s  
left join
(select imei,stat_date from dm_user_daily where stat_date between "2020-03-01" and "2020-04-07") t on s.imei = t.imei  
group by s.stat_date;

-- 累计计算
-- 层次查询
-- 分区排序
-- 动态group by

-- 普通型
select month,
       -- 按月份求和
       sum(amount) pay_amount,  
       -- 所有月份累计和
       sum(sum(amount)) over(order by month) s1,
       -- 前3个月累计和
       sum(sum(amount)) over(order by month rows between 3 preceding and current row) s2,
       -- 前一月后一月和本月累计和
       sum(sum(amount)) over(order by month rows between 1 preceding and 1 following) s3,   
       -- 前一月后一月本月平均值
       avg(sum(amount)) over(order by month rows between 1 preceding and 1 following) a1
from dw_pay_info        
group by month;    

-- 排序型
select uid,pv,  
       rank() over(partition by uid order by pv desc) as rn1,        -- 1,2,3,3,5
       dense_rank() over(partition by uid order by pv desc) as rn2,  -- 1,2,3,3,4
       row_number() over(partition by uid order by pv desc) as rn3   -- 1,2,3,4,5
from dw_log_info;

-- 前后型
lag(col,n,default) over(partition by ... order by ...)   -- 窗口内往上第n行的col值,null就取default
lead(col,n,default) over(partition by ... order by ...)  -- 窗口内往下第n行的col值,null就取default
-- 计算同比环比
lag(salary, 1, 0) over(partition by uid order by month) as prev_sal -- 环比,与上个月份进行比较 
lag(salary, 12, 0) over(partition by uid order by month) as prev_12_sal -- 同比,与上年度相同月份比较

-- 分组排序后
first_value(col) over(partition by ... order by ...)     -- 分组排序后第一行
last_value(col) over(partition by ... order by ...)      -- 分组排序后最后一行

-- 百分比型
- CUME_DIST over (order by ...)
- CUME_DIST over (partition by ... order by ...)
- PERCENT_RANK over(order by ...)
- PERCENT_RANK over(partition by ... order by ...)
```