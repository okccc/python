- [参考文档](http://lxw1234.com/archives/2019/08/473.htm)  
- 需求：数据量很大且每天只有少部分数据新增/更新,但业务要求每次都能查询所有历史数据变化状态,每天存一份全量数据太占空间  
- 拉链表：保存历史数据状态变化的同时可以节省存储空间  
```sql
-- 1.mysql订单表结构为  
create table orders (  
order_id        int,  
create_time     string,  
update_time     string,  
status          string  
) 
stored as textfile;  

-- 2.数据仓库的ods层有一张订单分区表,存放每天的增量数据  
create table ods_orders_inc (  
order_id        int,  
create_time     string,  
update_time     string,  
status          string  
) 
partitioned by (dt string)  
stored as textfile;  

-- 3.数据仓库的dw层有一张订单历史拉链表,存放订单的历史状态数据  
create table dw_orders_his (  
order_id        int,  
create_time     string,  
update_time     string,  
status          string,
-- 该状态的生命周期开始时间   
begin_date      string,
-- 该状态的生命周期结束时间,'9999-12-31'表示该状态仍有效,没有更新为下一个状态
end_date        string     
) 
stored as textfile;  

-- 查询当前所有有效记录(最新状态)
select * from dw_order_his where end_date = '9999-12-31';  
-- 查询20190621的历史快照(20190621这一天的数据变化情况)
-- 新增: begin_date = '2019-06-21' and end_date = '9999-12-31' 
-- 更新: begin_date < '2019-06-21' and end_date = '2019-06-21'
select * from dw_order_his where begin_date <= '2019-06-21' and end_date >= '2019-06-21';
```
### <font color=red>全量初始化</font>
- 假设在20190821这天做全量初始化,那么需要将包括20190820之前的所有数据都抽取到ods并刷新到dw  
```sql
-- 1.抽取全量数据到ods  
insert overwrite table ods_orders_inc partition (dt=20190820)  
select order_id,
       create_time,
       update_time,
       status  
from orders  
where create_time <= '2019-08-20';  
-- 2.从ods刷新到dw  
insert overwrite table dw_orders_his  
select order_id,
       create_time,
       update_time,
       status,  
       create_time as begin_date,  
       '9999-12-31' as end_date    
from ods_orders_inc  
where dt=20190820;  
```
### <font color=red>增量刷新历史数据</font>    
- 从20190822开始,需要每天刷新前一天的更新数据到历史表  
```sql
-- 1.通过增量抽取,先将2019-08-21的数据抽取到ods  
insert overwrite table ods_orders_inc partition (dt=20190821)  
select order_id,
       create_time,
       update_time,
       status  
from orders  
where create_time = '2019-08-21' or update_time = '2019-08-21';    
-- 2.关联dw_orders_his历史数据(截止到20190820)和ods_orders_inc增量数据(20190821)刷新拉链表  
insert overwrite table dw_orders_his
select order_id,  
       create_time,  
       update_time,  
       status,  
       begin_date,  
       end_date  
from (
    select a.order_id,  
           a.create_time,  
           a.update_time,  
           a.status,  
           a.begin_date,  
           -- 能关联上说明状态有变化,也就是create_time<'2019-08-21' and update_time='2019-08-21'那部分数据,需要将end_date改成更新时间的前一天
           -- 关联不上有两种情况：1.原有订单状态未发生变化,那么end_date保持不变  2.create_time='2019-08-21'那部分新增订单,使用union all拼接
           case when b.order_id is not null then '2019-08-20' else a.end_date end as end_date  
    from dw_orders_his a  
    left join  
    (select * from ods_orders_inc where dt=20190821 and create_time < '2019-08-21') b on a.order_id = b.order_id 
	
    union all
	
    select order_id,  
           create_time,  
           update_time,  
           status,  
           '2019-08-21' as begin_date,  
           '9999-12-31' as end_date  
    from ods_orders_inc  
    where dt=20190821 
	  and create_time = '2019-08-21'
) t  
order by order_id,begin_date;  
``` 